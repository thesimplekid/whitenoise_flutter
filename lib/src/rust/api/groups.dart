// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../api.dart';
import '../frb_generated.dart';
import 'accounts.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Converts a `GroupId` to its hexadecimal string representation.
///
/// This function is used to serialize GroupId objects for storage or transmission
/// to Flutter, as GroupId cannot be directly serialized across the bridge.
///
/// # Parameters
/// * `group_id` - Reference to a GroupId object
///
/// # Returns
/// Hexadecimal string representation of the group ID
Future<String> groupIdToString({required GroupId groupId}) =>
    RustLib.instance.api.crateApiGroupsGroupIdToString(groupId: groupId);

/// Converts a hexadecimal string back to a `GroupId` object.
///
/// This function deserializes a hex string representation back into a GroupId
/// object for use with the core Whitenoise library.
///
/// # Parameters
/// * `hex_string` - Hexadecimal string representation of a group ID
///
/// # Returns
/// * `Ok(GroupId)` - Successfully parsed group ID
/// * `Err(WhitenoiseError)` - If the hex string is invalid or malformed
Future<GroupId> groupIdFromString({required String hexString}) =>
    RustLib.instance.api.crateApiGroupsGroupIdFromString(hexString: hexString);

/// Converts a core `Group` object to a Flutter-compatible `GroupData` structure.
///
/// This function handles the conversion of complex types like timestamps, public keys,
/// and group IDs to their string representations for Flutter compatibility.
///
/// # Parameters
/// * `group` - Reference to a core Group object
///
/// # Returns
/// A GroupData struct with all fields converted for Flutter compatibility
Future<GroupData> convertGroupToData({required Group group}) =>
    RustLib.instance.api.crateApiGroupsConvertGroupToData(group: group);

/// Fetches all active groups that an account is a member of.
///
/// This function retrieves all groups where the specified account is an active member,
/// returning them as Flutter-compatible GroupData structures.
///
/// # Parameters
/// * `pubkey` - The public key of the account whose groups to fetch
///
/// # Returns
/// * `Ok(Vec<GroupData>)` - Vector of group data for all active groups
/// * `Err(WhitenoiseError)` - If there was an error fetching groups or account not found
Future<List<GroupData>> fetchGroups({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiGroupsFetchGroups(pubkey: pubkey);

/// Fetches all members of a specific group.
///
/// This function retrieves the public keys of all current members in the specified group.
/// The requesting account must be a member of the group to access this information.
///
/// # Parameters
/// * `pubkey` - The public key of the account making the request (must be a group member)
/// * `group_id` - The unique identifier of the group
///
/// # Returns
/// * `Ok(Vec<PublicKey>)` - Vector of public keys for all group members
/// * `Err(WhitenoiseError)` - If there was an error fetching members or insufficient permissions
Future<List<PublicKey>> fetchGroupMembers({
  required PublicKey pubkey,
  required GroupId groupId,
}) => RustLib.instance.api.crateApiGroupsFetchGroupMembers(
  pubkey: pubkey,
  groupId: groupId,
);

/// Fetches all administrators of a specific group.
///
/// This function retrieves the public keys of all administrators for the specified group.
/// Administrators have special privileges such as adding/removing members and managing group settings.
///
/// # Parameters
/// * `pubkey` - The public key of the account making the request (must be a group member)
/// * `group_id` - The unique identifier of the group
///
/// # Returns
/// * `Ok(Vec<PublicKey>)` - Vector of public keys for all group administrators
/// * `Err(WhitenoiseError)` - If there was an error fetching admins or insufficient permissions
Future<List<PublicKey>> fetchGroupAdmins({
  required PublicKey pubkey,
  required GroupId groupId,
}) => RustLib.instance.api.crateApiGroupsFetchGroupAdmins(
  pubkey: pubkey,
  groupId: groupId,
);

/// Creates a new MLS group with specified members and administrators.
///
/// This function creates a new group using the MLS (Message Layer Security) protocol,
/// setting up the initial member list and administrative privileges. The creator
/// automatically becomes a group administrator.
///
/// # Parameters
/// * `creator_pubkey` - The public key of the account creating the group (becomes admin)
/// * `member_pubkeys` - Vector of public keys for initial group members
/// * `admin_pubkeys` - Vector of public keys for initial group administrators
/// * `group_name` - Human-readable name for the group
/// * `group_description` - Description of the group's purpose
///
/// # Returns
/// * `Ok(GroupData)` - The created group data if successful
/// * `Err(WhitenoiseError)` - If there was an error creating the group
///
/// # Notes
/// * All members must have published key packages to relays
/// * The creator is automatically added as both member and admin
/// * Group creation may take time as it involves MLS protocol setup
Future<GroupData> createGroup({
  required PublicKey creatorPubkey,
  required List<PublicKey> memberPubkeys,
  required List<PublicKey> adminPubkeys,
  required String groupName,
  required String groupDescription,
}) => RustLib.instance.api.crateApiGroupsCreateGroup(
  creatorPubkey: creatorPubkey,
  memberPubkeys: memberPubkeys,
  adminPubkeys: adminPubkeys,
  groupName: groupName,
  groupDescription: groupDescription,
);

/// This method adds new members to an existing MLS group. The calling account must have
/// administrative privileges for the group. The operation will update the group's MLS
/// epoch and distribute the updated group state to all existing members.
///
/// # Arguments
/// * `pubkey` - The public key of the account performing the operation (must be a group admin)
/// * `group_id` - The MLS group ID to add members to
/// * `member_pubkeys` - A vector of public keys for the new members to add
///
/// # Returns
/// * `Ok(())` - If the members were successfully added to the group
/// * `Err(WhitenoiseError)` - If there was an error adding members (e.g., insufficient permissions, invalid group ID, or MLS protocol errors)
///
/// # Notes
/// * Only group administrators can add new members
/// * Each new member must have a valid key package published to relays
/// * The group epoch will be incremented after successful member addition
/// * All existing group members will receive an update with the new group composition
Future<void> addMembersToGroup({
  required PublicKey pubkey,
  required GroupId groupId,
  required List<PublicKey> memberPubkeys,
}) => RustLib.instance.api.crateApiGroupsAddMembersToGroup(
  pubkey: pubkey,
  groupId: groupId,
  memberPubkeys: memberPubkeys,
);

/// This method removes existing members from an MLS group. The calling account must have
/// administrative privileges for the group. The operation will update the group's MLS
/// epoch and distribute the updated group state to all remaining members.
///
/// # Arguments
/// * `pubkey` - The public key of the account performing the operation (must be a group admin)
/// * `group_id` - The MLS group ID to remove members from
/// * `member_pubkeys` - A vector of public keys for the members to remove
///
/// # Returns
/// * `Ok(())` - If the members were successfully removed from the group
/// * `Err(WhitenoiseError)` - If there was an error removing members (e.g., insufficient permissions, invalid group ID, member not found, or MLS protocol errors)
///
/// # Notes
/// * Only group administrators can remove members
/// * Administrators cannot remove themselves from the group
/// * Removed members will lose access to future group messages
/// * The group epoch will be incremented after successful member removal
/// * All remaining group members will receive an update with the new group composition
/// * Removed members will not be notified of their removal through the MLS protocol
Future<void> removeMembersFromGroup({
  required PublicKey pubkey,
  required GroupId groupId,
  required List<PublicKey> memberPubkeys,
}) => RustLib.instance.api.crateApiGroupsRemoveMembersFromGroup(
  pubkey: pubkey,
  groupId: groupId,
  memberPubkeys: memberPubkeys,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Group>>
abstract class Group implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GroupId>>
abstract class GroupId implements RustOpaqueInterface {}

class GroupData {
  final String mlsGroupId;
  final String nostrGroupId;
  final String name;
  final String description;
  final List<String> adminPubkeys;
  final String? lastMessageId;
  final BigInt? lastMessageAt;
  final GroupType groupType;
  final BigInt epoch;
  final GroupState state;

  const GroupData({
    required this.mlsGroupId,
    required this.nostrGroupId,
    required this.name,
    required this.description,
    required this.adminPubkeys,
    this.lastMessageId,
    this.lastMessageAt,
    required this.groupType,
    required this.epoch,
    required this.state,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      nostrGroupId.hashCode ^
      name.hashCode ^
      description.hashCode ^
      adminPubkeys.hashCode ^
      lastMessageId.hashCode ^
      lastMessageAt.hashCode ^
      groupType.hashCode ^
      epoch.hashCode ^
      state.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupData &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          nostrGroupId == other.nostrGroupId &&
          name == other.name &&
          description == other.description &&
          adminPubkeys == other.adminPubkeys &&
          lastMessageId == other.lastMessageId &&
          lastMessageAt == other.lastMessageAt &&
          groupType == other.groupType &&
          epoch == other.epoch &&
          state == other.state;
}

enum GroupState {
  active,
  inactive,
  pending,
}

enum GroupType {
  directMessage,
  group,
}
