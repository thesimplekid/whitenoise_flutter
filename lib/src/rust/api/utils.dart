// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../api.dart';
import '../frb_generated.dart';
import 'accounts.dart';
import 'messages.dart';
import 'relays.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

/// Converts a core `Metadata` object to a Flutter-compatible `MetadataData` structure.
///
/// This function handles the conversion of the `custom` field from `BTreeMap<String, serde_json::Value>`
/// to `BTreeMap<String, String>`, converting JSON values to their string representations.
/// Arrays and objects are serialized to JSON strings.
///
/// # Parameters
/// * `metadata` - Reference to a core Metadata object
///
/// # Returns
/// A MetadataData struct with all fields converted for Flutter compatibility
///
/// # Example
/// ```rust
/// let core_metadata = Metadata { /* ... */ };
/// let flutter_metadata = convert_metadata_to_data(&core_metadata);
/// ```
Future<MetadataData> convertMetadataToData({required Metadata metadata}) =>
    RustLib.instance.api.crateApiUtilsConvertMetadataToData(metadata: metadata);

/// Converts a Flutter-compatible `MetadataData` structure back to a core `Metadata` object.
///
/// This function reverses the conversion performed by `convert_metadata_to_data`,
/// attempting to parse string values back to JSON where possible, falling back to
/// string values when parsing fails.
///
/// # Parameters
/// * `metadata_data` - Reference to a MetadataData struct
///
/// # Returns
/// A core Metadata object suitable for use with the Whitenoise library
///
/// # Example
/// ```rust
/// let flutter_metadata = MetadataData { /* ... */ };
/// let core_metadata = convert_metadata_data_to_metadata(&flutter_metadata);
/// ```
Future<Metadata> convertMetadataDataToMetadata({
  required MetadataData metadataData,
}) => RustLib.instance.api.crateApiUtilsConvertMetadataDataToMetadata(
  metadataData: metadataData,
);

/// Parses a public key from a string representation.
///
/// This function accepts both hexadecimal and npub (bech32) formats for public keys,
/// providing flexibility for different input sources.
///
/// # Parameters
/// * `public_key_string` - String representation of a public key (hex or npub format)
///
/// # Returns
/// * `Ok(PublicKey)` - Successfully parsed public key
/// * `Err(WhitenoiseError)` - If parsing fails due to invalid format
///
/// # Example
/// ```rust
/// // From hex format
/// let pubkey = public_key_from_string("abc123...".to_string())?;
///
/// // From npub format
/// let pubkey = public_key_from_string("npub1...".to_string())?;
/// ```
Future<PublicKey> publicKeyFromString({required String publicKeyString}) =>
    RustLib.instance.api.crateApiUtilsPublicKeyFromString(
      publicKeyString: publicKeyString,
    );

/// Converts a `PublicKey` object to npub (bech32) format.
///
/// The npub format is the human-readable bech32 encoding used in Nostr for public keys,
/// making them easier to share and verify visually.
///
/// # Parameters
/// * `public_key` - Reference to a PublicKey object
///
/// # Returns
/// * `Ok(String)` - npub representation (e.g., "npub1...")
/// * `Err(WhitenoiseError)` - If conversion fails
///
/// # Example
/// ```rust
/// let pubkey = PublicKey::parse("abc123...")?;
/// let npub = npub_from_public_key(&pubkey)?;
/// println!("npub: {}", npub); // npub1...
/// ```
Future<String> npubFromPublicKey({required PublicKey publicKey}) =>
    RustLib.instance.api.crateApiUtilsNpubFromPublicKey(publicKey: publicKey);

/// Converts a hexadecimal public key string to npub format.
///
/// This is a convenience function that combines parsing and conversion in one step.
///
/// # Parameters
/// * `hex_pubkey` - Hexadecimal string representation of a public key
///
/// # Returns
/// * `Ok(String)` - npub representation
/// * `Err(WhitenoiseError)` - If parsing or conversion fails
///
/// # Example
/// ```rust
/// let npub = npub_from_hex_pubkey("abc123...")?;
/// println!("npub: {}", npub);
/// ```
Future<String> npubFromHexPubkey({required String hexPubkey}) =>
    RustLib.instance.api.crateApiUtilsNpubFromHexPubkey(hexPubkey: hexPubkey);

/// Converts an npub (bech32) public key to hexadecimal format.
///
/// This function is useful when you need the raw hex representation of a public key
/// for cryptographic operations or storage.
///
/// # Parameters
/// * `npub` - npub string representation of a public key (e.g., "npub1...")
///
/// # Returns
/// * `Ok(String)` - Hexadecimal representation
/// * `Err(WhitenoiseError)` - If parsing or conversion fails
///
/// # Example
/// ```rust
/// let hex = hex_pubkey_from_npub("npub1...")?;
/// println!("hex: {}", hex);
/// ```
Future<String> hexPubkeyFromNpub({required String npub}) =>
    RustLib.instance.api.crateApiUtilsHexPubkeyFromNpub(npub: npub);

/// Converts a `PublicKey` object to hexadecimal string format.
///
/// This provides direct access to the hex representation of a PublicKey object.
///
/// # Parameters
/// * `public_key` - Reference to a PublicKey object
///
/// # Returns
/// * `Ok(String)` - Hexadecimal representation
/// * `Err(WhitenoiseError)` - If conversion fails
///
/// # Example
/// ```rust
/// let pubkey = PublicKey::parse("npub1...")?;
/// let hex = hex_pubkey_from_public_key(&pubkey)?;
/// ```
Future<String> hexPubkeyFromPublicKey({required PublicKey publicKey}) => RustLib
    .instance
    .api
    .crateApiUtilsHexPubkeyFromPublicKey(publicKey: publicKey);

/// Parses a relay URL from a string.
///
/// This function validates and creates a RelayUrl object from a string,
/// ensuring proper URL format for Nostr relays (typically WebSocket URLs).
///
/// # Parameters
/// * `url` - String representation of a relay URL (e.g., "wss://relay.example.com")
///
/// # Returns
/// * `Ok(RelayUrl)` - Successfully parsed and validated relay URL
/// * `Err(WhitenoiseError)` - If the URL is invalid or malformed
///
/// # Example
/// ```rust
/// let relay = relay_url_from_string("wss://relay.damus.io".to_string())?;
/// ```
Future<RelayUrl> relayUrlFromString({required String url}) =>
    RustLib.instance.api.crateApiUtilsRelayUrlFromString(url: url);

/// Converts a `RelayUrl` object to its string representation.
///
/// This function provides the string representation of a relay URL for display
/// or serialization purposes.
///
/// # Parameters
/// * `relay_url` - Reference to a RelayUrl object
///
/// # Returns
/// String representation of the relay URL
///
/// # Example
/// ```rust
/// let relay = RelayUrl::parse("wss://relay.damus.io")?;
/// let url_string = string_from_relay_url(&relay);
/// println!("Relay URL: {}", url_string);
/// ```
Future<String> stringFromRelayUrl({required RelayUrl relayUrl}) =>
    RustLib.instance.api.crateApiUtilsStringFromRelayUrl(relayUrl: relayUrl);

/// Creates a `WhitenoiseConfig` object from string directory paths.
///
/// This function bridges the gap between Flutter's string-based paths and Rust's
/// `Path` types, creating a proper configuration object for Whitenoise initialization.
///
/// # Parameters
/// * `data_dir` - Path string for data directory where app data will be stored
/// * `logs_dir` - Path string for logs directory where log files will be written
///
/// # Returns
/// A WhitenoiseConfig object ready for initialization
///
/// # Example
/// ```rust
/// let config = create_whitenoise_config(
///     "/path/to/data".to_string(),
///     "/path/to/logs".to_string()
/// );
/// ```
Future<WhitenoiseConfig> createWhitenoiseConfig({
  required String dataDir,
  required String logsDir,
}) => RustLib.instance.api.crateApiUtilsCreateWhitenoiseConfig(
  dataDir: dataDir,
  logsDir: logsDir,
);

/// Converts a `WhitenoiseConfig` object to a Flutter-compatible `WhitenoiseConfigData` structure.
///
/// This function allows Flutter to access configuration data in a compatible format,
/// converting Path objects back to strings.
///
/// # Parameters
/// * `config` - Reference to a WhitenoiseConfig object
///
/// # Returns
/// A WhitenoiseConfigData struct with string representations of the paths
///
/// # Example
/// ```rust
/// let config = WhitenoiseConfig::new(data_path, logs_path);
/// let config_data = convert_config_to_data(&config);
/// ```
Future<WhitenoiseConfigData> convertConfigToData({
  required WhitenoiseConfig config,
}) => RustLib.instance.api.crateApiUtilsConvertConfigToData(config: config);

/// Creates a `Tag` object from a vector of strings.
///
/// Tags are used in Nostr events for various metadata and references such as
/// mentions, replies, and other event relationships.
///
/// # Parameters
/// * `vec` - Vector of strings representing tag components (e.g., ["p", "pubkey", "relay"])
///
/// # Returns
/// * `Ok(Tag)` - Successfully created tag object
/// * `Err(WhitenoiseError)` - If tag creation fails due to invalid format
///
/// # Example
/// ```rust
/// // Create a "p" tag for mentioning a user
/// let tag = tag_from_vec(vec!["p".to_string(), "pubkey123".to_string()])?;
/// ```
Future<Tag> tagFromVec({required List<String> vec}) =>
    RustLib.instance.api.crateApiUtilsTagFromVec(vec: vec);

/// Converts a `WhitenoiseError` to a human-readable string representation.
///
/// This function provides error information that can be displayed in the Flutter UI,
/// using debug formatting to include detailed error context.
///
/// # Parameters
/// * `error` - Reference to a WhitenoiseError
///
/// # Returns
/// String representation of the error with debug information
///
/// # Example
/// ```rust
/// match some_operation() {
///     Ok(result) => println!("Success: {:?}", result),
///     Err(e) => println!("Error: {}", whitenoise_error_to_string(&e)),
/// }
/// ```
Future<String> whitenoiseErrorToString({required WhitenoiseError error}) =>
    RustLib.instance.api.crateApiUtilsWhitenoiseErrorToString(error: error);

/// Creates an ImageType::Png variant.
///
/// This function provides a way to create PNG ImageType instances from Flutter
/// for use with profile picture upload functionality.
///
/// # Returns
/// ImageType::Png variant
///
/// # Example
/// ```dart
/// final pngType = imageTypePng();
/// await uploadProfilePicture(pubkey, serverUrl, filePath, pngType);
/// ```
Future<ImageType> imageTypePng() =>
    RustLib.instance.api.crateApiUtilsImageTypePng();

/// Creates an ImageType::Jpeg variant.
///
/// This function provides a way to create JPEG ImageType instances from Flutter
/// for use with profile picture upload functionality.
///
/// # Returns
/// ImageType::Jpeg variant
///
/// # Example
/// ```dart
/// final jpegType = imageTypeJpeg();
/// await uploadProfilePicture(pubkey, serverUrl, filePath, jpegType);
/// ```
Future<ImageType> imageTypeJpeg() =>
    RustLib.instance.api.crateApiUtilsImageTypeJpeg();

/// Creates an ImageType::Jpg variant.
///
/// This function provides a way to create JPG ImageType instances from Flutter
/// for use with profile picture upload functionality.
///
/// # Returns
/// ImageType::Jpg variant
///
/// # Example
/// ```dart
/// final jpgType = imageTypeJpg();
/// await uploadProfilePicture(pubkey, serverUrl, filePath, jpgType);
/// ```
Future<ImageType> imageTypeJpg() =>
    RustLib.instance.api.crateApiUtilsImageTypeJpg();

/// Creates an ImageType::Gif variant.
///
/// This function provides a way to create GIF ImageType instances from Flutter
/// for use with profile picture upload functionality.
///
/// # Returns
/// ImageType::Gif variant
///
/// # Example
/// ```dart
/// final gifType = imageTypeGif();
/// await uploadProfilePicture(pubkey, serverUrl, filePath, gifType);
/// ```
Future<ImageType> imageTypeGif() =>
    RustLib.instance.api.crateApiUtilsImageTypeGif();

/// Creates an ImageType::Webp variant.
///
/// This function provides a way to create WebP ImageType instances from Flutter
/// for use with profile picture upload functionality.
///
/// # Returns
/// ImageType::Webp variant
///
/// # Example
/// ```dart
/// final webpType = imageTypeWebp();
/// await uploadProfilePicture(pubkey, serverUrl, filePath, webpType);
/// ```
Future<ImageType> imageTypeWebp() =>
    RustLib.instance.api.crateApiUtilsImageTypeWebp();

/// Determines the appropriate ImageType based on a file extension.
///
/// This helper function maps common image file extensions to their corresponding
/// ImageType variants for convenient use in Flutter.
///
/// # Parameters
/// * `extension` - File extension string (e.g., "jpg", "png", ".jpeg")
///
/// # Returns
/// * `Ok(ImageType)` - Appropriate ImageType for the extension
/// * `Err(WhitenoiseError)` - If the extension is not supported
///
/// # Example
/// ```dart
/// final imageType = imageTypeFromExtension("jpg")?;
/// await uploadProfilePicture(pubkey, serverUrl, filePath, imageType);
/// ```
Future<ImageType> imageTypeFromExtension({required String extension_}) =>
    RustLib.instance.api.crateApiUtilsImageTypeFromExtension(
      extension_: extension_,
    );

/// Returns the default Blossom server URL based on build configuration.
///
/// This function provides the appropriate Blossom server URL for image uploads:
/// - Development builds use localhost (requires local docker setup)
/// - Release builds use the production Primal Blossom server
///
/// # Returns
/// String containing the default Blossom server URL
///
/// # Example
/// ```dart
/// final serverUrl = getDefaultBlossomServerUrl();
/// await uploadProfilePicture(pubkey, serverUrl, filePath, imageType);
/// ```
Future<String> getDefaultBlossomServerUrl() =>
    RustLib.instance.api.crateApiUtilsGetDefaultBlossomServerUrl();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Metadata>>
abstract class Metadata implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MetadataData>>
abstract class MetadataData implements RustOpaqueInterface {
  String? get about;

  String? get banner;

  String? get displayName;

  String? get lud06;

  String? get lud16;

  String? get name;

  String? get nip05;

  String? get picture;

  String? get website;

  set about(String? about);

  set banner(String? banner);

  set displayName(String? displayName);

  set lud06(String? lud06);

  set lud16(String? lud16);

  set name(String? name);

  set nip05(String? nip05);

  set picture(String? picture);

  set website(String? website);

  /// Retrieves the custom metadata fields as a HashMap.
  ///
  /// This method provides access to the private `custom` field, converting from
  /// `BTreeMap` to `HashMap` for Flutter compatibility.
  ///
  /// # Returns
  /// A HashMap containing all custom key-value pairs
  ///
  /// # Example
  /// ```rust
  /// let metadata = MetadataData { /* ... */ };
  /// let custom_fields = metadata.get_custom();
  /// println!("Custom fields: {:?}", custom_fields);
  /// ```
  Future<Map<String, String>> getCustom();

  /// Sets the custom metadata fields from a HashMap.
  ///
  /// This method allows updating the private `custom` field, converting from
  /// `HashMap` to `BTreeMap` internally for consistent ordering.
  ///
  /// # Parameters
  /// * `custom_map` - A HashMap containing custom key-value pairs to store
  ///
  /// # Example
  /// ```rust
  /// let mut metadata = MetadataData { /* ... */ };
  /// let mut custom = HashMap::new();
  /// custom.insert("theme".to_string(), "dark".to_string());
  /// metadata.set_custom(custom);
  /// ```
  Future<void> setCustom({required Map<String, String> customMap});
}

/// Flutter-compatible configuration structure that holds directory paths as strings.
///
/// This struct is used to pass configuration data from Flutter to Rust, as flutter_rust_bridge
/// cannot directly handle `Path` types. The paths are converted to proper `Path` objects
/// internally when creating a `WhitenoiseConfig`.
class WhitenoiseConfigData {
  /// Path to the directory where application data will be stored
  final String dataDir;

  /// Path to the directory where log files will be written
  final String logsDir;

  const WhitenoiseConfigData({required this.dataDir, required this.logsDir});

  @override
  int get hashCode => dataDir.hashCode ^ logsDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WhitenoiseConfigData &&
          runtimeType == other.runtimeType &&
          dataDir == other.dataDir &&
          logsDir == other.logsDir;
}
